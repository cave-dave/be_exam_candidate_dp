/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package guitest;

import java.awt.Toolkit;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.nio.file.Paths;
import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicBoolean;
import javax.swing.JFileChooser;

/**
 * This class will create a form with which a User can specify a folder to be watched.
 * Whenever a new CSV file is placed into that directory, it will be converted to a JSON
 * file and placed into the specified output directory while any errors will be logged in 
 * a CSV file within the specified error directory. The original CSV file will then be deleted.
 * 
 * @author Dave Paupst
 */
public class CSV_2_JSON extends javax.swing.JFrame {

    /** Collection of <code>String</code> file names that have already been processed. */
    private final ArrayList<String> processed_files;
    /** Thread-safe boolean for input directory selection. */
    private final AtomicBoolean inputDirectoryChosen;
    /** Thread-safe boolean for output directory selection. */
    private final AtomicBoolean outputDirectoryChosen;
    /** Thread-safe boolean for error directory selection. */
    private final AtomicBoolean errorDirectoryChosen;
    /** File chooser set for directories only. */
    private final JFileChooser chooser;
    
    /**
     * Creates new form UserInput
     */
    public CSV_2_JSON() {
        initComponents();       
        
        inputDirectoryChosen = new AtomicBoolean(false);
        outputDirectoryChosen = new AtomicBoolean(false);
        errorDirectoryChosen = new AtomicBoolean(false);
        
        processed_files = new ArrayList<>();
        
        chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File("."));
        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        chooser.setAcceptAllFileFilterUsed(false);        
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        txtField_InputDir = new javax.swing.JTextField();
        cmd_LookupInput = new javax.swing.JButton();
        cmd_ClearInput = new javax.swing.JButton();
        txtField_OutputDir = new javax.swing.JTextField();
        cmd_LookupOutput = new javax.swing.JButton();
        cmd_ClearOutput = new javax.swing.JButton();
        txtField_ErrorDir = new javax.swing.JTextField();
        cmd_LookupError = new javax.swing.JButton();
        cmd_ClearError = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txt_Info = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("CSV to JSON Converter");
        setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("/guitest/scoir.jpg")));
        setResizable(false);

        txtField_InputDir.setEditable(false);
        txtField_InputDir.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        txtField_InputDir.setText("Please select Input Directory");

        cmd_LookupInput.setIcon(new javax.swing.ImageIcon(getClass().getResource("/guitest/dir.png"))); // NOI18N
        cmd_LookupInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_LookupInputActionPerformed(evt);
            }
        });

        cmd_ClearInput.setText("Clear Selection");
        cmd_ClearInput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_ClearInputActionPerformed(evt);
            }
        });

        txtField_OutputDir.setEditable(false);
        txtField_OutputDir.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        txtField_OutputDir.setText("Please select Output Directory");

        cmd_LookupOutput.setIcon(new javax.swing.ImageIcon(getClass().getResource("/guitest/dir.png"))); // NOI18N
        cmd_LookupOutput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_LookupOutputActionPerformed(evt);
            }
        });

        cmd_ClearOutput.setText("Clear Selection");
        cmd_ClearOutput.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_ClearOutputActionPerformed(evt);
            }
        });

        txtField_ErrorDir.setEditable(false);
        txtField_ErrorDir.setFont(new java.awt.Font("Tahoma", 0, 12)); // NOI18N
        txtField_ErrorDir.setText("Please select Error Directory");

        cmd_LookupError.setIcon(new javax.swing.ImageIcon(getClass().getResource("/guitest/dir.png"))); // NOI18N
        cmd_LookupError.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_LookupErrorActionPerformed(evt);
            }
        });

        cmd_ClearError.setText("Clear Selection");
        cmd_ClearError.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cmd_ClearErrorActionPerformed(evt);
            }
        });

        txt_Info.setColumns(20);
        txt_Info.setRows(5);
        jScrollPane1.setViewportView(txt_Info);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(txtField_InputDir, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(cmd_LookupInput))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(txtField_OutputDir, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(cmd_LookupOutput))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(txtField_ErrorDir, javax.swing.GroupLayout.PREFERRED_SIZE, 336, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(cmd_LookupError))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 401, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(143, 143, 143)
                        .addComponent(cmd_ClearInput))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(142, 142, 142)
                        .addComponent(cmd_ClearOutput))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(141, 141, 141)
                        .addComponent(cmd_ClearError)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(txtField_InputDir, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cmd_LookupInput))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cmd_ClearInput)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(txtField_OutputDir, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cmd_LookupOutput))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cmd_ClearOutput)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(txtField_ErrorDir, javax.swing.GroupLayout.PREFERRED_SIZE, 33, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cmd_LookupError))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(cmd_ClearError)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Getter operation for the Input Directory.
     * @return <code>String</code> -- The input directory.
     */
    private String getInputDirectory() {
        return txtField_InputDir.getText();
    }
    
    /**
     * Setter operation for the Input Directory.
     * @param userDir <code>String</code> -- Name of the input directory.
     */
    private void setInputDirectory(String userDir) {
        txtField_InputDir.setText(userDir);
    }
    
    /**
     * Getter operation for the Output Directory.
     * @return <code>String</code> -- The output directory.
     */
    private String getOutputDirectory() {
        return txtField_OutputDir.getText();
    }
    
    /**
     * Setter operation for the Output Directory.
     * @param userDir <code>String</code> -- Name of the output directory.
     */
    private void setOutputDirectory(String userDir) {
        txtField_OutputDir.setText(userDir);
    }
    
    /**
     * Getter operation for the Error Directory.
     * @return <code>String</code> -- The error directory.
     */
    private String getErrorDirectory() {
        return txtField_ErrorDir.getText();
    }
    
    /**
     * Setter operation for the Error Directory.
     * @param userDir <code>String</code> -- Name of the error directory.
     */
    private void setErrorDirectory(String userDir) {
        txtField_ErrorDir.setText(userDir);
    }
    
    /**
     * Utilizes the <code>JFileChooser</code> in order to set the text field of 
     * the specified directory. If all three directories have been chosen then 
     * the directory watcher will be started.
     * 
     * @param dirSelected <code>String</code> -- INPUT, OUTPUT, or ERROR
     */
    private void chooseDirectory(String dirSelected) {
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            String userDir = chooser.getSelectedFile().getAbsolutePath();
            switch (dirSelected) {
                case "INPUT":
                    setInputDirectory(userDir);
                    inputDirectoryChosen.set(true);
                    break;
                case "OUTPUT":
                    setOutputDirectory(userDir);
                    outputDirectoryChosen.set(true);
                    break;
                case "ERROR":
                    setErrorDirectory(userDir);
                    errorDirectoryChosen.set(true);
                    break;
            }
        } else {
            //NO SELECTION MADE
        }
        
        if (inputDirectoryChosen.get() && outputDirectoryChosen.get() && errorDirectoryChosen.get()) {
            DirectoryWatching DW = new DirectoryWatching();
            Thread t = new Thread(DW);
            t.start();
        }
    }
    
    /**
     * This private class will run a thread to watch the selected Input Directory.
     * When a new CSV file appears in the selected directory (and has a unique name
     * that has not already been processed), it will be converted to JSON.
     * That new JSON file will be placed into the selected output directory, 
     * any errors will be logged in a new CSV file in the error directory and the 
     * original CSV file will be deleted.
     */
    private class DirectoryWatching implements Runnable {
        
        @Override
        public void run() {
            try {
            
            WatchService watcher = FileSystems.getDefault().newWatchService();
            Path dir = Paths.get(getInputDirectory());            
            dir.register(watcher, ENTRY_CREATE);

            while (inputDirectoryChosen.get() && outputDirectoryChosen.get() && errorDirectoryChosen.get()) {
                WatchKey key;
                try {
                    key = watcher.take();
                } catch (InterruptedException ex) {
                    return;
                }

                if (inputDirectoryChosen.get() && outputDirectoryChosen.get() && errorDirectoryChosen.get()) {
                    key.pollEvents().stream().forEach((event) -> {
                        WatchEvent.Kind<?> kind = event.kind();
                        WatchEvent<Path> ev = (WatchEvent<Path>) event;
                        Path fileName = ev.context();
                        if (kind == ENTRY_CREATE && fileName.toString().contains(".csv") && !processed_files.contains(fileName.toString())) {
                            txt_Info.append("-------------------------\nWe have a new CSV file! ----- ' " + fileName.toString() + " '\n");
                            processed_files.add(fileName.toString());
                            processFile(new File(new File(getInputDirectory()), fileName.toString()));
                        }
                    });
                } else {
                    txt_Info.append("A new CSV file was detected but conversion cannot be performed without selecting all appropriate directories.\n");
                }
                boolean valid = key.reset();
                if (!valid) {
                    break;
                }
            }
            
            } catch (IOException e) {}
        }
        
        /**
         * Based on conditions given for the CSV columns, this method will convert the given 
         * CSV file to a JSON file.
         * @param CSVFile 
         */
        private void processFile(File CSVFile) {
            final String Internal_ID_REGEX = "^[0-9]{8}$";
            final int Name_LENGTH = 15;
            final String Phone_REGEX = "^[0-9]{3}\\-[0-9]{3}\\-[0-9]{4}$";
            final String[] correctHeaders = {"INTERNAL_ID", "FIRST_NAME", "MIDDLE_NAME", "LAST_NAME", "PHONE_NUM"};
            final int COLUMN_AMOUNT = 5;
            
            boolean errorsOccured = false;
            boolean dirtyRecord = false;
            int errorCount = 0;
            String errorToWrite = "";
            String outputToWrite = "";
            
            try {                                
                BufferedReader read = new BufferedReader(new FileReader(CSVFile));                
                
                File outputFile = new File(new File(getOutputDirectory()), CSVFile.getName().replace(".csv", ".json"));
                BufferedWriter outputWrite = new BufferedWriter(new FileWriter(outputFile));
                
                File errorFile = new File(new File(getErrorDirectory()), CSVFile.getName());
                BufferedWriter errorWrite = new BufferedWriter(new FileWriter(errorFile));
                errorWrite.write("LINE_NUM,ERROR_MSG\n");
                
                String line = read.readLine();
                String columns[] = {""};
                if (line != null) {
                    columns = line.split(",");
                }
                if (!Arrays.equals(columns, correctHeaders)) {
                    errorWrite.write("1,Incorrect Headers ----- Headers Given: " + Arrays.toString(columns).replaceAll(",", " - ") + "\n");
                    errorsOccured = true;
                    errorCount++;
                }
                
                int line_Num = 2;
                
                while((line = read.readLine()) != null) {
                    String tokens[] = line.split(",");
                    dirtyRecord = false;
                    
                    if (tokens.length == COLUMN_AMOUNT) {
                    	outputToWrite = "{\n";
                    	errorToWrite = "";
                        
                        String internal_ID = tokens[0];
                        if (internal_ID.matches(Internal_ID_REGEX)) {
                            outputToWrite += "\tid: " + internal_ID + ",";
                        } else {
                            errorToWrite += line_Num + ",Incorrect format for INTERNAL_ID number. ----- Input Given: " + internal_ID + "\n";
                            dirtyRecord = true;
                            errorCount++;
                        }
                        
                        outputToWrite += "\n\tname: {\n";
                        
                        String firstName = tokens[1];
                        if (firstName.length() > 0 && firstName.length() <= Name_LENGTH) {
                            if (!dirtyRecord) outputToWrite += "\t\tfirst: \"" + firstName + "\",\n";
                        } else {
                            errorToWrite += line_Num + ",Incorrect format for FIRST_NAME field. ----- Input Given: " + firstName + "\n";
                            dirtyRecord = true;
                            errorCount++;
                        }
                        
                        String middleName = tokens[2];
                        if (middleName.length() > 0 && middleName.length() <= Name_LENGTH) {
                        	if (!dirtyRecord) outputToWrite += "\t\tmiddle: \"" + middleName + "\",\n";
                        }
                        else if (tokens[2].length() > Name_LENGTH) {
                            errorToWrite += line_Num + ",Incorrect format for MIDDLE_NAME field. ----- Input Given: " + middleName + "\n";
                            dirtyRecord = true;
                            errorCount++;
                        }
                        
                        String lastName = tokens[3];
                        if (lastName.length() > 0 && lastName.length() <= Name_LENGTH) {
                        	if (!dirtyRecord) outputToWrite += "\t\tlast: \"" + lastName + "\"";
                        } else {
                            errorToWrite += line_Num + ",Incorrect format for LAST_NAME field. ----- Input Given: " + lastName + "\n";
                            dirtyRecord = true;
                            errorCount++;
                        }
                        
                        outputToWrite += "\n\t},\n";
                        
                        String phone = tokens[4];
                        if (phone.matches(Phone_REGEX)) {
                        	if (!dirtyRecord) outputToWrite += "\tphone: \"" + phone + "\"";
                        } else {
                            errorToWrite += line_Num + ",Incorrect format for PHONE_NUMBER field. ----- Input Given: " + phone + "\n";
                            dirtyRecord = true;
                            errorCount++;
                        }
                        
                        outputToWrite += "\n}\n";
                        line_Num++;
                    } else {
                        errorToWrite += line_Num + ",Incorrect format not enough columns. ----- Input Given: " + Arrays.toString(tokens).replaceAll(",", " - ") + "\n";
                        line_Num++;
                    }
                    
                    if (dirtyRecord) {
                        errorsOccured = true;
                        errorWrite.write(errorToWrite);
                    } else {
                        outputWrite.write(outputToWrite);
                    }
                }
                
                if (errorsOccured) {
                    txt_Info.append(errorCount + " errors occured in conversion of ' " + CSVFile.getName() + " '\n");
                } else {
                    txt_Info.append("' " + CSVFile.getName() + " ' was converted successfully with 0 errors.\n");
                    errorFile.delete();                    
                }
                
                outputWrite.close();
                errorWrite.close();
                read.close();
                
                if (!CSVFile.delete()) {
                    txt_Info.append("Error deleting ' " + CSVFile.getName() + " ', file was not deleted.\n");
                }
                
                
            } catch (IOException e) {}
        }
    }
    
    /**
     * Action performed for the Input Directory Lookup button.
     * Uses the <code>chooseDirectory</code> method to launch <code>JFileChooser</code>.
     * @param evt 
     */
    private void cmd_LookupInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_LookupInputActionPerformed
        chooseDirectory("INPUT");
    }//GEN-LAST:event_cmd_LookupInputActionPerformed
    
    /**
     * Clears the currently selected Input Directory.
     * @param evt 
     */
    private void cmd_ClearInputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_ClearInputActionPerformed
        inputDirectoryChosen.set(false);        
        if (!getInputDirectory().equals("Please select Input Directory")) {
            txt_Info.append("Input directory selection cleared.\n");
        }
        setInputDirectory("Please select Input Directory");
    }//GEN-LAST:event_cmd_ClearInputActionPerformed

    /**
     * Action performed for the Output Directory Lookup button.
     * Uses the <code>chooseDirectory</code> method to launch <code>JFileChooser</code>.
     * @param evt 
     */
    private void cmd_LookupOutputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_LookupOutputActionPerformed
        chooseDirectory("OUTPUT");
    }//GEN-LAST:event_cmd_LookupOutputActionPerformed

    /**
     * Clears the currently selected Output Directory.
     * @param evt 
     */
    private void cmd_ClearOutputActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_ClearOutputActionPerformed
        outputDirectoryChosen.set(false);        
        if (!getOutputDirectory().equals("Please select Output Directory")) {
            txt_Info.append("Output directory selection cleared.\n");
        }
        setOutputDirectory("Please select Output Directory");
    }//GEN-LAST:event_cmd_ClearOutputActionPerformed

    /**
     * Action performed for the Error Directory Lookup button.
     * Uses the <code>chooseDirectory</code> method to launch <code>JFileChooser</code>.
     * @param evt 
     */
    private void cmd_LookupErrorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_LookupErrorActionPerformed
        chooseDirectory("ERROR");
    }//GEN-LAST:event_cmd_LookupErrorActionPerformed

    /**
     * Clears the currently selected Error Directory.
     * @param evt 
     */
    private void cmd_ClearErrorActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cmd_ClearErrorActionPerformed
        errorDirectoryChosen.set(false);        
        if (!getErrorDirectory().equals("Please select Error Directory")) {
            txt_Info.append("Error directory selection cleared.\n");
        }
        setErrorDirectory("Please select Error Directory");
    }//GEN-LAST:event_cmd_ClearErrorActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CSV_2_JSON.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new CSV_2_JSON().setVisible(true);                
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton cmd_ClearError;
    private javax.swing.JButton cmd_ClearInput;
    private javax.swing.JButton cmd_ClearOutput;
    private javax.swing.JButton cmd_LookupError;
    private javax.swing.JButton cmd_LookupInput;
    private javax.swing.JButton cmd_LookupOutput;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField txtField_ErrorDir;
    private javax.swing.JTextField txtField_InputDir;
    private javax.swing.JTextField txtField_OutputDir;
    private javax.swing.JTextArea txt_Info;
    // End of variables declaration//GEN-END:variables
}
